`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
//
// Implements shake256 algorithm
//
// Keccak HW architecture following the pseudocode algorithm specified in https://keccak.team/keccak_specs_summary.html
//
// This and child modules originally created by Sujoy Sinha Roy and heavily modified by Vid Smole for the Falcon project.
//
//////////////////////////////////////////////////////////////////////////////////

module shake256(
    input logic clk,
    input logic rst, // Active high (not like the rest of the design)

    input logic [15:0] input_len_bytes,// Message length in bytes. If message is less than 64 bits, then the most significant bits are 0s.
    input logic [63:0] data_in,
    input logic data_in_valid,

    output logic ready_in,// when this signal is high, that means we can receive data via "data_in"
    output logic[63:0] data_out,  // 64-bit PRNG word output from Keccak state
    output logic data_out_valid // This signal is used to write Keccak-squeeze output
  );

  logic absorb_done; // Becomes 1 after the entire input message is absorbed.
  logic squeeze_done; // Becomes 1 when the entire input is absorbed.

  logic [63:0] data_in_padded;    // Properly padded message coming from keccak_absorb. It will be XORed with the State buffer.
  logic data_in_padded_valid;                       // This signal is generated by keccak_absorb to XOR data_in_padded with State.
  logic call_keccak_f1600_absorb;      // This is 1 to initiate F1600 on the state during Absorb.
  logic keccak_round_complete;         // Generated by Keccak-f1600 after it finishes a F1600.

  logic [25*64-1:0] state_out;         // 25*64 bit state output from Keccak Buffer. It will be processed inside f1600 permutation.
  logic [25*64-1:0] state_in;          // 25*64 bit new state value that will be written into the state bufer
  logic write_state_in;                // Write enable signal for writing the new state value into the state buffer.

  logic [4:0] state_reg_sel;           // This is used to select State[0]..to..State[rate] (at most). Note that only 64-bits are output every cycle.
  logic we_output_buffer;       // Used to write keccak_state into keccak_output_buffer
  logic shift_output_buffer;    // Used to shift the keccak_output_buffer in 64 bits such that one word is output
  logic call_keccak_f1600_squeeze;     // This is 1 to initiate F1600 on the state during Squeeze

  logic [2:0] FSM_state, FSM_next_state;

  logic rst_absorb, rst_state, rst_squeeze;
  logic rst_rounds;

  // Reset clears the state buffer.
  // The first step is shake256_absorb. This module is the FSM. It also does necessary padding to the message.
  shake256_absorb absorb(
                    .clk(clk),
                    .rst(rst_absorb),
                    .inputlen_InBytes(input_len_bytes),
                    .din_64bit_raw(data_in),
                    .din_valid(data_in_valid),
                    .ready(ready_in),
                    .data_in_padded(data_in_padded),
                    .data_in_padded_valid(data_in_padded_valid),
                    .call_keccak_f1600(call_keccak_f1600_absorb),
                    .keccak_round_complete(keccak_round_complete),
                    .done(absorb_done)
                  );

  shake256_state state(
                   .clk(clk),
                   .rst(rst_state),
                   .din_64bit(data_in_padded),
                   .data_in_padded_valid(data_in_padded_valid),
                   .state_out(state_out),
                   .state_in(state_in),
                   .we_state_in(write_state_in),
                   .state_output_sel(state_reg_sel),
                   .we_output_buffer(we_output_buffer),
                   .shift_output_buffer(shift_output_buffer),
                   .dout_64bit(data_out)
                 );


  shake256_rounds rounds(
                    .clk(clk),
                    .rst(rst_rounds),
                    .state_in(state_out),
                    .state_out(state_in),
                    .we_state_out(write_state_in),
                    .final_round(keccak_round_complete)
                  );


  shake256_squeeze squeeze(
                     .clk(clk),
                     .rst(rst_squeeze),
                     .call_keccak_f1600(call_keccak_f1600_squeeze),
                     .keccak_round_complete(keccak_round_complete),
                     .state_reg_sel(state_reg_sel),
                     .we_output_buffer(we_output_buffer),
                     .shift_output_buffer(shift_output_buffer),
                     .data_out_valid(data_out_valid),
                     .done(squeeze_done)
                   );

  assign rst_rounds = (rst_absorb==1'b0) ? ~call_keccak_f1600_absorb : (rst_squeeze==1'b0) ? ~call_keccak_f1600_squeeze : 1'b1;

  always @(posedge clk) begin
    if(rst)
      FSM_state <= 3'd0;
    else
      FSM_state <= FSM_next_state;
  end

  always @(FSM_state) begin
    case(FSM_state)
      3'd0: begin     // Reset state; Clear state buffer.
        rst_absorb<=1;
        rst_state<=1;
        rst_squeeze<=1;
      end

      3'd1: begin     // Absorb input
        rst_absorb<=0;
        rst_state<=0;
        rst_squeeze<=1;
      end

      3'd2: begin     // Squeeze
        rst_absorb<=1;
        rst_state<=0;
        rst_squeeze<=0;
      end

      3'd3: begin     // End state; Reset all.
        rst_absorb<=1;
        rst_state<=1;
        rst_squeeze<=1;
      end
      default: begin
        rst_absorb<=1;
        rst_state<=1;
        rst_squeeze<=1;
      end
    endcase
  end

  always @(FSM_state or absorb_done or squeeze_done) begin
    case(FSM_state)
      3'd0:
        FSM_next_state <= 3'd1;

      3'd1: begin
        if(absorb_done)
          FSM_next_state <= 3'd2;
        else
          FSM_next_state <= 3'd1;
      end

      3'd2: begin
        if(squeeze_done)
          FSM_next_state <= 3'd3;
        else
          FSM_next_state <= 3'd2;
      end

      3'd3:
        FSM_next_state <= 3'd3;
      default:
        FSM_next_state <= 3'd0;
    endcase
  end

endmodule
