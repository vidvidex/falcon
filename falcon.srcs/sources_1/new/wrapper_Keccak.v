`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company:
// Engineer:
//
// Create Date: 12/28/2020 09:42:33 AM
// Design Name: Wrapper around Keccak core to support SHA, SHAKE functionalities.
// Module Name: wrapper_Keccak
// Project Name:
// Target Devices:
// Tool Versions:
// Description:
//
// Dependencies:
// Developer: Sujoy Sinha Roy
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
//
//////////////////////////////////////////////////////////////////////////////////

// This is a wrapper around the Keccak core to implement SHA, SHAKE, etc. functionalities.
// Addiionally, this wrapper handles 64-bit read/write operations between BRAM and Keccak.
// Keccak(rate, capacity, input, inputByteLen, delimitedSuffix, output, outputByteLen);
// where rate+capacity=1600.

// SHAKE128(const unsigned char *input, unsigned int inputByteLen, unsigned char *output, int outputByteLen)
// -->  Keccak(1344, 256, input, inputByteLen, 0x1F, output, outputByteLen);

// SHAKE256(const unsigned char *input, unsigned int inputByteLen, unsigned char *output, int outputByteLen)
// -->  Keccak(1088, 512, input, inputByteLen, 0x1F, output, outputByteLen);

// SHA3_256(const unsigned char *input, unsigned int inputByteLen, unsigned char *output)
// -->  Keccak(1088, 512, input, inputByteLen, 0x06, output, 32);

// SHA3_512(const unsigned char *input, unsigned int inputByteLen, unsigned char *output)
// -->  Keccak(576, 1024, input, inputByteLen, 0x06, output, 64);

module wrapper_Keccak(clk, rst, shake_intermediate_rst,
                        inputByteLen, outputByteLen,
                        read_address, din_64bit,
                        write_address, dout_64bit, we, done);


  input clk;
  input rst;  // Active high reset

  input shake_intermediate_rst;
  wire shake_next_extract=0;
  input [15:0] inputByteLen, outputByteLen;
  output [8:0] read_address;
  input [63:0] din_64bit;

  output [8:0] write_address;
  output [63:0] dout_64bit;
  output we;
  output done;

  //wire [11:0] rateInBits;        // Note that maximum rateInBytes = 1344/8 = 168
  wire [7:0] rateInBytes;        // Note that maximum rateInBytes = 1344/8 = 168
  wire [7:0] delimitedSuffix;    // Keccak parameter
  wire [15:0] inputLen_InBytes, outputLen_InBytes;
  wire keccak_is_ready_to_receive;    // Output from Keccak. It is 1 when Keccak can accept data.
  wire dout_valid;                    // Generated by Keccak. This is 1 when Keccak is producing dout_64bit.
  wire keccak_absorb_done, keccak_squeeze_done;

  reg din_valid_r;
  reg [63:0] din_64bit_latched;
  wire [63:0] din_64bit_to_keccak;
  reg [9:0] read_address, write_address;
  reg use_latched_din;
  reg din_valid;
  reg rst_keccak;
  reg keccak_squeeze_resume;
  reg inc_read_address, inc_write_address;
  reg keccak_is_ready_to_receive_r;
  wire keccak_notready_to_ready_transition;      // This signal becomes 1 just for 1 cycle when Keccak_ready status transits from 0 to 1.
  wire read_complete;

  reg [3:0] state, nextstate;



  assign rateInBytes       =  8'd136 ;
  assign delimitedSuffix   =  8'h1f ;
  assign inputLen_InBytes  =  inputByteLen;
  assign outputLen_InBytes =  outputByteLen[15:0];
  assign we                =  dout_valid;



  //wire [15:0] inputByteLen_minus1 = inputByteLen - 1'b1;
  //assign read_complete = (read_address==inputByteLen_minus1[12:3]);



  always @(posedge clk) begin
    din_valid_r <= din_valid;
    if(din_valid_r)
      din_64bit_latched <= din_64bit;
    else
      din_64bit_latched <= din_64bit_latched;
  end

  assign din_64bit_to_keccak = (use_latched_din) ? din_64bit_latched : (din_64bit & {64{~rst}}) ; // GATED

  keccak_speed    KeccakCore(
                    clk, rst_keccak, /*rateInBits*/ rateInBytes, delimitedSuffix,
                    inputLen_InBytes, outputLen_InBytes,
                    keccak_is_ready_to_receive, din_64bit_to_keccak, din_valid,
                    keccak_squeeze_resume, dout_64bit, dout_valid,
                    keccak_absorb_done, keccak_squeeze_done);

  always @(posedge clk)
    keccak_is_ready_to_receive_r<=keccak_is_ready_to_receive;

  assign keccak_notready_to_ready_transition = (keccak_is_ready_to_receive==1'b1 && keccak_is_ready_to_receive_r==1'b0);

  always @(posedge clk) begin
    if(rst)
      read_address <= 10'd0;
    else if(inc_read_address)
      read_address <= read_address + 1'b1;
    else
      read_address <= read_address;
  end

  always @(posedge clk) begin
    if(rst || shake_intermediate_rst)
      write_address <= 10'd0;
    else if(we)
      write_address <= write_address + 1'b1;
    else
      write_address <= write_address;
  end

  always @(posedge clk) begin
    if(rst)
      state <= 4'd0;
    else
      state <= nextstate;
  end

  always @(state or keccak_is_ready_to_receive or keccak_notready_to_ready_transition) begin
    case(state)
      4'd0: begin // Reset state
        rst_keccak<=1;
        keccak_squeeze_resume<=0;
        use_latched_din<=0;
        inc_read_address<=0;
        din_valid<=0;
      end

      4'd1: begin // Init Absorb state; Wait here untill keccak_is_ready_to_receive becomes 1.
        rst_keccak<=0;
        keccak_squeeze_resume<=0;
        use_latched_din<=0;
        inc_read_address<=0;
        din_valid<=0;
      end
      4'd2: begin // Absorb state; Fetch data from BRAM in 64 bit words.
        rst_keccak<=0;
        keccak_squeeze_resume<=0;
        use_latched_din<=0;
        inc_read_address<=1;
        din_valid<=0;
      end
      4'd3: begin // Absorb state; Fetch data from BRAM in 64 bit words. Always check if keccak_is_ready_to_receive is 1.
        rst_keccak<=0;
        keccak_squeeze_resume<=0;
        if(keccak_is_ready_to_receive) begin
          inc_read_address<=1;
          din_valid<=1;
        end
        else begin
          inc_read_address<=0;
          din_valid<=0;
        end
        if(keccak_notready_to_ready_transition)
          use_latched_din<=1;
        else
          use_latched_din<=0;
      end
      /* Example:
      addrInc= 1 1 1 1 1 0 0 0 1 1 1 1 0 0 0 1  1 1 
      address= 0 1 2 3 4 5 5 5 5 6 7 8 9 9 9 9  a b
      dataIn =   0 1 2 3 4 5 5 L 5 6 7 8 9 9 L  9 a
      valid  =   1 1 1 1 0 0 0 1 1 1 1 0 0 0 1  1 1
      Keccak = R R R R R N N N R R R R N N N R  R R
      Here R means Keccak is ready to receive data, N means not ready.
      L means latched data when valid_reg was 1. Thus the first L povides latched data from address 3.           
      */
      4'd4: begin // Squeeze
        rst_keccak<=0;
        keccak_squeeze_resume<=1;
        use_latched_din<=0;
        inc_read_address<=0;
        din_valid<=0;
      end
      4'd5: begin // End
        rst_keccak<=0;
        keccak_squeeze_resume<=0;
        use_latched_din<=0;
        inc_read_address<=0;
        din_valid<=0;
      end
      4'd6: begin	// End state
        rst_keccak<=0;
        keccak_squeeze_resume<=0;
        use_latched_din<=0;
        inc_read_address<=0;
        din_valid<=0;
      end

      4'd7: begin	// End state
        rst_keccak<=0;
        keccak_squeeze_resume<=0;
        use_latched_din<=0;
        inc_read_address<=0;
        din_valid<=0;
      end

      4'd8: begin	// End state
        rst_keccak<=0;
        keccak_squeeze_resume<=0;
        use_latched_din<=0;
        inc_read_address<=0;
        din_valid<=0;
      end
      default: begin // Reset state
        rst_keccak<=1;
        keccak_squeeze_resume<=0;
        use_latched_din<=0;
        inc_read_address<=0;
        din_valid<=0;
        inc_write_address<=0;
      end
    endcase
  end

  always @(state or keccak_is_ready_to_receive or keccak_absorb_done or keccak_squeeze_done or shake_next_extract or shake_intermediate_rst) begin

    case(state)
      4'd0:
        nextstate <= 4'd1;
      4'd1: begin
        if(keccak_is_ready_to_receive)
          nextstate <= 4'd2;
        else
          nextstate <= 4'd1;
      end
      4'd2:
        nextstate <= 4'd3;
      4'd3: begin
        if(keccak_absorb_done)
          nextstate <= 4'd4;
        else
          nextstate <= 4'd3;
      end
      4'd4: begin
        if(keccak_squeeze_done)
          nextstate <= 4'd5;
        else
          nextstate <= 4'd4;
      end
      4'd5:
        nextstate <= 4'd6;
      4'd6:
        nextstate <= 4'd8;
      4'd7: begin
        if(shake_next_extract)
          nextstate <= 4'd4;
        else
          nextstate <= 4'd7;
      end
      4'd8: begin
        if(shake_intermediate_rst)
          nextstate <= 4'd7;
        else
          nextstate <= 4'd8;
      end

      default:
        nextstate <= 4'd0;

    endcase
  end


  assign done = (state==4'd8);


endmodule
