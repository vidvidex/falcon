`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
//
// Implements shake256 algorithm
//
// Keccak HW architecture following the pseudocode algorithm specified in https://keccak.team/keccak_specs_summary.html
//
// This and child modules originally created by Sujoy Sinha Roy and heavily modified by Vid Smole for the Falcon project.
//
//////////////////////////////////////////////////////////////////////////////////

module shake256(
    input logic clk,
    input logic rst, //! Active high (not like the rest of the design!)

    input logic [15:0] input_len_bytes, //! Message length in bytes. If message is less than 64 bits, then the most significant bits are 0s.
    input logic [63:0] data_in,
    input logic valid_in,

    output logic[15:0] data_out,  //! 16-bit PRNG word output from Keccak state
    output logic valid_out //! This signal is used to write Keccak-squeeze output
  );

  logic absorb_done; //! Becomes 1 after the entire input message is absorbed.
  logic squeeze_done; //! Becomes 1 when the entire input is absorbed.

  logic [63:0] data_in_padded;    //! Properly padded message coming from keccak_absorb. It will be XORed with the State buffer.
  logic data_in_padded_valid;     //! This signal is generated by keccak_absorb to XOR data_in_padded with State.
  logic call_keccak_f1600_absorb; //! This is 1 to initiate F1600 on the state during Absorb.
  logic keccak_round_complete;    //! Generated by Keccak-f1600 after it finishes a F1600.

  logic [25*64-1:0] state_out;    //! 25*64 bit state output from Keccak Buffer. It will be processed inside f1600 permutation.
  logic [25*64-1:0] state_in;     //! 25*64 bit new state value that will be written into the state bufer
  logic write_state_in;           //! Write enable signal for writing the new state value into the state buffer.

  logic we_output_buffer;       //! Used to write keccak_state into keccak_output_buffer
  logic shift_output_buffer;    //! Used to shift the keccak_output_buffer in 64 bits such that one word is output
  logic call_keccak_f1600_squeeze;     //! This is 1 to initiate F1600 on the state during Squeeze

  typedef enum logic [1:0] {
            IDLE,
            ABSORB,
            SQUEEZE,
            FINALIZE
          } state_t;
  state_t state, next_state;

  logic rst_absorb, rst_state, rst_squeeze;
  logic rst_rounds;

  // Reset clears the state buffer.
  // The first step is shake256_absorb. This module is the FSM. It also does necessary padding to the message.
  shake256_absorb shake256_absorb(
                    .clk(clk),
                    .rst(rst_absorb),
                    .inputlen_InBytes(input_len_bytes),
                    .data_in(data_in),
                    .valid_in(valid_in),
                    .data_in_padded(data_in_padded),
                    .data_in_padded_valid(data_in_padded_valid),
                    .call_keccak_f1600(call_keccak_f1600_absorb),
                    .keccak_round_complete(keccak_round_complete),
                    .done(absorb_done)
                  );

  shake256_state shake256_state(
                   .clk(clk),
                   .rst(rst_state),
                   .data_in(data_in_padded),
                   .data_in_padded_valid(data_in_padded_valid),
                   .state_out(state_out),
                   .state_in(state_in),
                   .we_state_in(write_state_in),
                   .we_output_buffer(we_output_buffer),
                   .shift_output_buffer(shift_output_buffer),
                   .data_out(data_out)
                 );

  shake256_rounds shake256_rounds(
                    .clk(clk),
                    .rst(rst_rounds),
                    .state_in(state_out),
                    .state_out(state_in),
                    .we_state_out(write_state_in),
                    .final_round(keccak_round_complete)
                  );

  shake256_squeeze shake256_squeeze(
                     .clk(clk),
                     .rst(rst_squeeze),
                     .call_keccak_f1600(call_keccak_f1600_squeeze),
                     .keccak_round_complete(keccak_round_complete),
                     .we_output_buffer(we_output_buffer),
                     .shift_output_buffer(shift_output_buffer),
                     .valid_out(valid_out),
                     .done(squeeze_done)
                   );

  assign rst_rounds = (rst_absorb==1'b0) ? ~call_keccak_f1600_absorb : (rst_squeeze==1'b0) ? ~call_keccak_f1600_squeeze : 1'b1;

  always_ff @(posedge clk) begin
    if(rst)
      state <= IDLE;
    else
      state <= next_state;
  end

  always_comb begin
    case(state)
      IDLE: begin     // Reset state; Clear state buffer.
        rst_absorb <= 1;
        rst_state <= 1;
        rst_squeeze <= 1;
      end

      ABSORB: begin     // Absorb input
        rst_absorb <= 0;
        rst_state <= 0;
        rst_squeeze <= 1;
      end

      SQUEEZE: begin     // Squeeze
        rst_absorb <= 1;
        rst_state <= 0;
        rst_squeeze <= 0;
      end

      FINALIZE: begin     // End state; Reset all.
        rst_absorb <= 1;
        rst_state <= 1;
        rst_squeeze <= 1;
      end

      default: begin
        rst_absorb <= 1;
        rst_state <= 1;
        rst_squeeze <= 1;
      end
    endcase
  end

  always_comb begin
    case(state)
      IDLE:
        next_state = ABSORB;

      ABSORB: begin
        if(absorb_done)
          next_state = SQUEEZE;
        else
          next_state = ABSORB;
      end

      SQUEEZE: begin
        if(squeeze_done)
          next_state = FINALIZE;
        else
          next_state = SQUEEZE;
      end

      FINALIZE:
        next_state = FINALIZE;

      default:
        next_state = IDLE;
    endcase
  end

endmodule
